import os
import sys
import pdbtools
from Bio.PDB.PDBParser import PDBParser
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

''' 

Command Line use example:

	python MakePDBContactMaps.py "./QAB653_raptorX_model_1.pdb"

This script cleans up some poorly formatted pdb file. It's use is particularly helpful
when dealing with pdb file outputs generated by C-I-Tasser and I-Tasser. For some reason,
these outputs do not have an elements column and some other strange formatting that causes
errors when the files are used by Biopython to get DSSP and ACC values. It also causes
errors when creating the model evaluations.

If there are any problems with this script please reach out to Richard Pearson.
email: richard.pearson@sjsu.edu

'''


def clean_up_pdb_file(file_path):
	# This function will accept a pdb file path as input and return a
	# more properly formatted pdb file to that same directory

	directory = os.path.split(file_path)[0]
	#print(f'directory: {directory}')
	
	pdb_file = os.path.split(file_path)[1]
	#print(f'pdb_file: {pdb_file}')
	
	protein_name = os.path.splitext(pdb_file)[0]
	#print(f'protein_name: {protein_name}')
	
	file_ext = os.path.splitext(pdb_file)[1]
	#print(f'file_ext: {file_ext}')

	# pdb_sort PDB File
	sort_file_name = protein_name + "_sort" + file_ext
	os.system(f'pdb_sort "{os.path.join(directory, pdb_file)}" > "{os.path.join(directory, sort_file_name)}"')

	# pdb_tidy PDB file
	tidy_file_name = protein_name + "_tidy" + file_ext
	os.system(f'pdb_tidy -strict "{os.path.join(directory, sort_file_name)}" > "{os.path.join(directory, tidy_file_name)}"')

	# pdb_element PDB file
	element_file_name = protein_name + "_element" + file_ext
	os.system(f'pdb_element "{os.path.join(directory, tidy_file_name)}" > "{os.path.join(directory, element_file_name)}"')

def get_model_coords(file_path):
	# funtion input is pdb file (preferably a cleaned up pdb file)
	# returns list of coordinates arrays
	
	directory = os.path.split(file_path)[0]
	pdb_file = os.path.split(file_path)[1]
	protein_name = os.path.splitext(pdb_file)[0]
	file_ext = os.path.splitext(pdb_file)[1]
	
	element_file_name = protein_name + "_element" + file_ext
	

	# Parse the cleaned up pdb file
	parser = PDBParser(PERMISSIVE=1)
	structure = parser.get_structure(protein_name, os.path.join(directory, element_file_name))
	
	ca_coord_list = []
	
	for model in structure.get_list():
		for chain in model.get_list():
			for i, residue in enumerate(chain.get_list()):
				if residue.has_id("CA"):
					ca = residue["CA"]
					coords = ca.get_coord()
					
					ca_coord_list.append(coords)
	
	return(ca_coord_list)
	
def get_alpha_carbon_distances(file_path):
	''' funtion input is pdb file (preferably a cleaned up pdb file)
		returns 2D list of @CA distances '''
	
	directory = os.path.split(file_path)[0]
	pdb_file = os.path.split(file_path)[1]
	protein_name = os.path.splitext(pdb_file)[0]
	file_ext = os.path.splitext(pdb_file)[1]
	
	element_file_name = protein_name + "_element" + file_ext
	

	# Parse the cleaned up pdb file
	parser = PDBParser(PERMISSIVE=1)
	structure = parser.get_structure(protein_name, os.path.join(directory, element_file_name))
	
	distance_list_2D = []
	
	for model in structure.get_list():
		for chain in model.get_list():
			for i, residue in enumerate(chain.get_list()):
				
				distance_list_1D = []
				
				if residue.has_id("CA"):
					res_a_num = i + 1
					ca1 = residue["CA"]
					for n, residue in enumerate(chain.get_list()):
						if residue.has_id("CA"):
							res_b_num = n + 1
							ca2 = residue["CA"]
							distance = ca1 - ca2
							
							distance_list_1D.append(distance)
	
				distance_list_2D.append(distance_list_1D)
	
	# Output a CSV file with all of the distances
	df = pd.DataFrame(data=distance_list_2D, columns=range(1, len(distance_list_2D)+1 ))
	df.index = df.index + 1
	distance_matrix_csv_name = protein_name + '_distances.csv'
	df.to_csv(distance_matrix_csv_name)
			
	return(distance_list_2D)

def create_heatmap(matrix, protein_name='', vmin=0, vmax=20):
	''' Create a heatmap using seaborn library '''
	
	# Throw error and exit function if matrix is empty
	if len(matrix) == 0:
		print("Error: The matrix is empty.")
		return

	# Throw error and exit if values in matrix are not compatible with heatmap
	matrix_np = np.array(matrix)
	if np.isnan(matrix_np).any() or np.isinf(matrix_np).any():
		print("Error: Invalid values found in the matrix.")
		return
	
	# Change matrix to dataframe and set columns and index to residue position values
	df = pd.DataFrame(data=matrix, columns=range(1, len(matrix)+1))
	df.index = df.index + 1
	
	# Define heatmap options
	sns.set()
	ax = sns.heatmap(df, vmin=vmin, vmax=vmax, cmap='viridis', square=True, xticklabels="auto", yticklabels="auto", cbar_kws={'label': 'Distance (Angstroms)'})
	ax.set(xlabel="Residue", ylabel="Residue")
	
	plt.subplots_adjust(bottom=0.15)
    
    # If the optional argument 'protein_name' is not set,
    # simply title the heatmap 'Contact Map'
	if protein_name != '':
		title = protein_name.upper() + " Contact Map"
	else:
		title = "Contact Map"
	plt.title(title)
	
	# Set the aspect ratio to square
	ax.set_aspect('equal')
	
	# Show the plot on the screen
	#plt.show()
	
	# Save the heatmap
	if protein_name != '':
		heatmap_image_name = protein_name + "_distance-heatmap.png"
	else:
		heatmap_image_name = "distance-heatmap.png"
	plt.savefig(heatmap_image_name)

def main(file_path):
	
	directory = os.path.split(file_path)[0]
	pdb_file = os.path.split(file_path)[1]
	protein_name = os.path.splitext(pdb_file)[0]
	file_ext = os.path.splitext(pdb_file)[1]
	
	# clean up pdb file (creates 3 additional pdb files that are altered)
	clean_up_pdb_file(file_path)
	
	# Get x,y,z coordinates of CA atoms in protein model
	coords = get_model_coords(file_path)

	# Get distances
	distances = get_alpha_carbon_distances(file_path)
	#print(distances)
	
	create_heatmap(distances, protein_name=protein_name)
	#create_heatmap_again(distances)

	
if __name__ == '__main__':
	main(sys.argv[1])
